<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LZW Compression</title>
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>
<body>
    <header>
        <h1>LZW Compression</h1>
        <nav>
            <ul>
                <li><a href="linear-search.html">Linear Search</a></li>
                <li><a href="binary-search.html">Binary Search</a></li>
                <li><a href="selection-sort.html">Selection Sort</a></li>
                <li><a href="insertion-sort.html">Insertion Sort</a></li>
                <li><a href="merge-sort.html">Merge Sort</a></li>
                <li><a href="quicksort.html">Quicksort</a></li>
                <li><a href="counting-sort.html">Counting Sort</a></li>
                <li><a href="radix-sort.html">Radix Sort</a></li>
                <li><a href="dijkstras.html">Dijkstraâ€™s Algorithm</a></li>
                <li><a href="bellman-ford.html">Bellman-Ford Algorithm</a></li>
                <li><a href="floyd-warshall.html">Floyd-Warshall Algorithm</a></li>
                <li><a href="huffman.html">Huffman Codes</a></li>
                <li><a href="lzw.html">LZW Compression</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
            <h2>What is LZW Compression?</h2>
            <p>LZW (Lempel-Ziv-Welch) is a lossless data compression algorithm that is widely used in various applications, including GIF images and UNIX compress utility. It works by replacing repeated occurrences of data with references to a single copy of that data.</p>
        </section>
        <section>
            <h2>How LZW Works</h2>
            <p>The algorithm builds a dictionary of input sequences during the encoding process. Each sequence is assigned a unique code. When a sequence is repeated, the algorithm outputs the code instead of the sequence itself, thus achieving compression.</p>
        </section>
        <section>
            <h2>Implementation</h2>
            <pre><code>
def lzw_compress(uncompressed):
    # Build the dictionary
    dict_size = 256
    dictionary = {chr(i): i for i in range(dict_size)}
    w = ""
    result = []
    
    for c in uncompressed:
        wc = w + c
        if wc in dictionary:
            w = wc
        else:
            result.append(dictionary[w])
            dictionary[wc] = dict_size
            dict_size += 1
            w = c
    
    if w:
        result.append(dictionary[w])
    
    return result
            </code></pre>
        </section>
        <section>
            <h2>Complexity Analysis</h2>
            <p>The time complexity of LZW compression is O(n), where n is the length of the input data. The space complexity depends on the size of the dictionary, which can grow with the input size.</p>
        </section>
    </main>
    <footer>
        <p>&copy; 2023 Algorithms Webpage</p>
    </footer>
    <script src="../assets/js/main.js"></script>
</body>
</html>